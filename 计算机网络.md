# 网络
### 1. 一个页面从输入url到页面显示完成，过程中都发生了什么？
1. url的解析
    * 分析需要的传输协议和请求的资源路径
2. 缓存判断
    * 浏览器会判断请求的资源是否存在缓存中
    * 如果请求的资源在缓存中，且没有失效，就会直接使用，否则会向服务器发生新的请求
3. DNS解析URL相对应地IP
4. 根据IP建立TCP的连接
    * 客户端向服务端发送一个SYN连接请求的报文
    * 服务端收到请求后向客服端发送一个ACK的确认连接的请求报文
    * 客户端收到确认的报文后，进入连接建立的状态，同时向服务端发送一个ACK确认报文，服务端收到确认后，也进入连接状态
    * 此时，双方的连接就建立起来了
    * TCP 为什么是三次握手，而不是两次或四次？

        * 两次不安全，四次浪费资源。
        * 三次握手，可以防止失效的连接请求报文段被服务端接收，从而产生错误。
        * 所谓失效的连接请求，是指客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。这样一个失效的连接请求，在网络中滞留许久后，到达服务端，服务端误以为是客户端再次发出的一个新的连接请求。
5. HTTPS握手（选说）： 
    * 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。
    * 首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。
    * 服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。
    * 客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。
    * 服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

5. 发送HTTP请求
    * 服务器处理请求，浏览器接收HTTP响应
6. 渲染页面，创建DOM树
    * 浏览器会根据响应返回的html文件进行解析，创建DOM树
    * 根据解析出的css文件构建CSSDOM树
    * 如果遇到script标签，会判断是否有defer、async属性，不然script的加载和执行会造成页面的渲染阻塞
    * 当DOM树和CSSDOM树创建好之后，利用他们创建渲染树
    * 之后，会根据渲染树绘制出整个页面
7. 关闭TCP连接（四次挥手）
    * 当客户端认为数据发送完成后，它会向服务端发送释放连接的请求
    * 服务端收到请求后告诉应用层释放TCP连接，然后发送ACK包，并进入CLOSE_WAIT状态，这个时候表明客户端到服务端的连接已经关闭，不再收到客户端的数据。
    * 之后，服务端向客户端发送连接释放的请求，然后服务端进入LAST-ACK状态
    * 客户端收到释放请求后，向服务端发送确认的报文，此时客户端进入TIME-WAIT状态
    * 该状态持续2MSL，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

### 2. websocket


### 3. Http和Https
- Https
    * HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。
    * 通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。
    * HTTPS主要作用是：
        1. 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;
        2. 对网站服务器进行真实身份认证。
    * 客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。
        1. 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
        2. Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
        3. 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
        4. 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
        5. Web服务器利用自己的私钥解密出会话密钥。
        6. Web服务器利用会话密钥加密与客户端之间的通信。

### 4. 浏览器缓存
- 浏览器缓存是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力。
- 强缓存
    * 请求的资源本地缓存中有,资源从本地缓存获取,不需要发起请求
    * 初次请求时，响应头中包含返回的资源和catch-control
    * 通过服务器设置的响应头字段cache-control或expires来设置缓存时间、缓存类型。
    * cache-control：
        1. 常用值：`max-age`(缓存时间)、immutable（在有效期内直接读取缓存）、`no-cache`(跳过强缓存，直接协商缓存)、`no-store`(跳过强缓存和协商缓存)
        2. expires 可以用来指定资源的过期时间，是一个绝对时间，由服务器决定
    * cache-control优先级高于expires

- 协商缓存
    * 协商缓存就是浏览器向服务器发送一个请求，服务器会检查该资源是否有更新，如果有更新，就返回最新的资源，状态码200，如果没有更新，状态码304，不返回资源，浏览器从缓存中读取资源。
    * 在客户端第一次向服务器发起请求时，通过服务器设置响应头etag（HTTP1.1）和last-modified（HTTP1.0）来指明资源标识和文件修改的时间。当浏览器再向服务器发起请求时，请求头会携带If-None-Match（对应etag）和If-Modified-Since（对应last-modified）来匹配资源和记录上次资源修改的时间（即上个响应头中的last-modified）。当匹配成功时，statecode为304，不会返回资源，客户端读取缓存。当匹配失败时，statecode为200，返回资源。


### 5. 网络安全

### 6. 常见的状态码
- 200：请求被正常处理
- 204：请求被受理但没有资源可以返回
- 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
- 301：永久性重定向
- 302：临时重定向
- 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
- 304：发送附带条件的请求时，条件不满足时返回，与重定向无关
- 307：临时重定向，与302类似，只是强制要求使用POST方法
- 400：请求报文语法有误，服务器无法识别
- 401：请求需要认证
- 403：请求的对应资源禁止被访问
- 404：服务器无法找到对应资源
- 500：服务器内部错误
- 503：服务器超过最大负荷

### 7. 如何进行网站性能优化
- 减少请求资源大小或者次数
    1. 尽量合并和压缩css和js，通过webpack
    2. 采用图片懒加载，减少页面第一次加载中的http请求次数
    3. 尽量所使用的字体图标或者SVG图标来代替传统png图,因为字体图标或者SVG是矢量图，代码编写出来的，放大不会变形，而且渲染速度快
    3. 避免引入第三方大量的库，而自己只用里面一个小功能
    4. 使用雪碧图或者是说图片精灵 把所有相对较小的资源图片，绘制在一张大图上，只需要将大图下载下来，然后利用图片定位来讲小图展现在页面中（background-position:百分比，数值）
    5. 减少对cookie的使用（最主要的就是减少本地cookie存储内容的大小），因为客户端操作cookie的时候，这些信息总是在客户端和服务端传递。如果上设置不当，每次发送一个请求将会携带cookie
    6. 前端与后端协商，合理使用keep-alive
- 代码相关
    1. 在js中尽量减少闭包的使用 原因：使用闭包后，闭包所在的上下文不会被释放
    2. 减少对DOM操作，主要是减少DOM的重绘与回流（重排）
    3. 在js中避免嵌套循环和"死循环"(一旦遇到死循环，浏览器就会直接卡掉)
    4. 把css放在body上，把js放在body下面 让其先加载css（注意：这里关于优化没有多大关系）
    5. 基于script标签下载js文件时，可以使用defer或者async来异步加载
    6. 在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数。
    7. 在js封装过程中，尽量做到低耦合高内聚。减少页面的冗余代码
- 缓存
    1. 结合后端，利用浏览器的缓存技术，做一些缓存（让后端返回304，告诉浏览器去本地拉取数据）。（注意：也有弊端）可以让一些不太会改变的静态资源做缓存。比如：一些图片，js，cs
    2. 利用h5的新特性（localStorage、sessionStorage）做一些简单数据的存储， 避免向后台请求数据或者说在离线状态下做一些数据展示。


# 缓存
## CDN缓存
#### 什么是cdn缓存
cdn缓存就是加在浏览器和服务器之间的一个缓存机制，缓存一些html/css/图片等一些静态资源。
#### 无CDN缓存时：
用户在浏览网站时，浏览器会缓存一些图片或者其他文件，当用户再次浏览时，就不需要再次下载文件了，提高了页面的加载速度。
#### 有cdn缓存时：
浏览器首先检查本地是否有缓存/缓存是否过期，如果缓存过期，会向最近的cdn边缘节点发送请求，cdn边缘节点会检查缓存的请求数据是否过期，如果没有过期则直接响应
客户，如果过期则cdn向源站点发送回源请求，获取最新的数据再返回给用户。
#### cdn缓存机制：
浏览器缓存失效时，浏览器会向cdn边缘节点发送请求，cdn边缘节点也有一套缓存机制。
1. 用户输入url时，浏览器会调用域名解析库对域名进行解析，得到的是该域名对应的CNAME记录，为了得到实际的IP，浏览器必须再一次进行解析，在这个过程中，使用
的是全局负载均衡DNS解析，根据就近原则及负荷情况，解析到最近最优的CDN缓存服务器的IP地址，浏览器向cdn缓存服务器发送请求，cdn缓存服务器根据浏览器提供的
域名，通过内部的DNS解析得到源服务器的IP地址，由cdn缓存服务器向该服务器发送请求。
## 浏览器缓存
### 强缓存 
强缓存是利用http返回头中Expires或者Cache-Control两个字段来控制的，用来表示资源缓存的时间。
#### Expires：
http1.0规范的，值是一个绝对的时间，代表资源的失效时间，存在的问题是如果浏览器与服务器之间的时间有差距，导致缓存混乱。
#### Cache-Contorl
* http1.1出现的，主要利用该字段的max-age值进行判断，它是一个相对时间，Cache-Control:max-age=3600
* 其他字段：
  1. no-cache表示不使用本地缓存，使用缓存协商。
  2. no-store：禁止缓存
### 协商缓存
协商缓存是由服务器来确定缓存资源是否可用
#### Last-Modify/If-Modify-Since
浏览器第一次请求时，服务器返回的header会加上Last-Modify。当浏览器再次请求时，request请求头会包含If-Modify-Since，服务器根据该头部，根据最后修改时间判断是否命中缓存，如果命中，返回304，并不会返回资源内容。
#### Etag/If-None-Match
与上面不同的是，Etag返回的是一个校验码，他可以保证每一个资源都是唯一的，资源变化会导致Eag变化，服务器根据浏览器发送的If-None-Match值判断是否命中缓存
#### 为什么要有Etag
* 一些文件周期性更改但是内容不改
* 某些文件修改频繁，If-Modified-Since能检查到s级别的。
* 某些服务器不能精确得到文件最后修改时间。

